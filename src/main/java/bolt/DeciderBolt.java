package bolt;

import clojure.lang.IFn;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import com.sun.javafx.scene.control.skin.VirtualFlow;
import org.apache.storm.task.OutputCollector;
import org.apache.storm.task.TopologyContext;
import org.apache.storm.topology.OutputFieldsDeclarer;
import org.apache.storm.topology.base.BaseRichBolt;
import org.apache.storm.tuple.Fields;
import org.apache.storm.tuple.Tuple;
import org.apache.storm.tuple.Values;
import type.TumblrPost;

import java.util.*;

public class DeciderBolt extends BaseRichBolt {
    private List<String> cPosts; //candidate posts that contains some keywords;
    private List<String> cTexts; //candifate texts
    private static int size; //the total size of seeds
    private static int length; //current keywords length
    private HashMap<String, List<String>> seeds;
    private OutputCollector collector;
    private Gson gson;
    private static String[] keywords;
    private static int count = 0;

    public DeciderBolt(String[] keywords) {
        DeciderBolt.keywords = keywords;
    }

    public final String SOME_MATCH_STREAM = "some match";
    public final String SEED_STREAM_ID = "seeds";
    public final String ON_TOPIC_STREAM = "on topic";
    public final String OFF_TOPIC_STREAM = "off topic";

    @Override
    public void prepare(Map map, TopologyContext topologyContext, OutputCollector outputCollector) {
        this.size = keywords.length;
        this.length = this.size;
        this.cPosts = new ArrayList<>();
        this.cTexts = new ArrayList<>();
        this.seeds = new HashMap<>();
        this.gson = new GsonBuilder().create();
        this.collector = outputCollector;

    }

    @Override
    public void execute(Tuple tuple) {
        //System.out.println("Decider Bolt: "+Arrays.asList(keywords)+" size: "+this.size+" count: "+this.count);
        if(this.length<this.size){
            this.length = this.size;
        }

        if(tuple.getSourceStreamId().equals(SOME_MATCH_STREAM)){
            /**
             * cache posts and wait until get all seeds
             */
            if(this.count<this.size){
                String raw = tuple.getStringByField("raw posts");
                String text = tuple.getStringByField("text");
                cTexts.add(text);
                cPosts.add(raw);
            }
        } else if (tuple.getSourceStreamId().equals(SEED_STREAM_ID)){
            String kw = tuple.getStringByField("keyword");
            List<String> sd = (List<String>) tuple.getValueByField("seeds");
            this.seeds.put(kw,sd);
            this.count++;
            //String kw = tuple.getStringByField("keyword");
            System.out.println(tuple.getStringByField("keyword")+":"+tuple.getValueByField("seeds"));
            if(this.count==this.length){
                for(int i=0;i<this.cTexts.size();i++){
                    if(isOnTopic(cTexts.get(i), cPosts.get(i))){
                        this.collector.emit(ON_TOPIC_STREAM, new Values(cPosts.get(i)));
                        //System.out.println("Decider Bolt: send a some match post");
                    }else{
                        this.collector.emit(OFF_TOPIC_STREAM, new Values(cPosts.get(i)));
                    }
                }

                this.cTexts = new ArrayList<>();
                this.cPosts = new ArrayList<>();
                this.seeds = new HashMap<>();
                this.count = 0;
            }
        }
        // if collected all seeds generated by model
        //System.out.println("DeciderBolt now have "+seeds.size()+" seeds");

    }

    private boolean isOnTopic(String t, String p) {
        int flagMatch = 0;
        HashMap<String, List<String>> tem = new HashMap<>(this.seeds);

        TumblrPost post = gson.fromJson(p, TumblrPost.class);
        List<String> matches = post.getMatch();

        if(matches.size()>=3){
            return true;
        } else if (matches.size()==0){
            return false;
        }

        for(String m:matches){
            if(tem.containsKey(m.trim())){
                tem.remove(m, tem.get(m));
            }
        }


        Iterator iterator = tem.entrySet().iterator();
        while (iterator.hasNext()){
            Map.Entry entry = (Map.Entry) iterator.next();
            List<String> temSeeds = (List<String>) entry.getValue();

            for(String s:temSeeds){
                if(t.contains(s.trim())||t.contains(s.replaceAll("_"," ").trim())){
                    flagMatch++;
                    break;
                }
            }

        }

        int sum = flagMatch+matches.size();

        if(this.count<6){
            if (sum >= 2) {
                return true;
            }
        }else {
            if (sum >= 3) {
                return true;
            }
        }

        return false;

    }

    @Override
    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {
        outputFieldsDeclarer.declareStream(ON_TOPIC_STREAM, new Fields("positive posts"));
        outputFieldsDeclarer.declareStream(OFF_TOPIC_STREAM, new Fields("negative posts"));
    }

    public void setKeywords(String[] keywords) {
        this.keywords = keywords;
        this.size = keywords.length;
    }
}
